\chapter{Technologies \& implémentations}
\label{Chapter3}

Ce chapitre reprend en détail chaque brique, en exposant pour chacune les recherches effectuées et des propositions de solutions pour leur implémentation ou mise en place.

\unsure{déplacer paragraphe ci-dessous ?}
Découvrant les domaines de l'urbanisme et de la modélisation du paysage avec la réalisation de ce projet, j'ai commencé par étudier les technologies et processus les plus répandus dans ces secteurs.
\todo{BIM \& CO ?}

\section{Formats de fichiers 3D}

Dans le cadre de la mise en place d'une plateforme de partage de modèles 3D, l'étude des formats de fichiers existants (usages, tendances, compatibilité...) est un point de départ intéressant. Cela permet tout d'abord de découvrir comment sont représentées les données de modélisation, et comment les manipuler. On prend également connaissance des logiciels principaux du marché.

Au final, cela aidera à décider quel(s) format(s) seraient à considérer pour notre outil, celui-ci devant pouvoir \textbf{supporter les formats les plus courants} afin d'être aisément utilisable.

Il existe plus d'une centaine de formats permettant de stocker des données tridimensionnelles. De nombreuses listes de ces derniers sont disponibles sur internet, mais la plupart ne mentionnent que les principaux formats. La section consacrée à cette catégorie de fichiers sur \textit{Wikipédia}\footnote{\url{https://en.wikipedia.org/wiki/List_of_file_formats\#3D_graphics}} s'avère être l'une des plus fournies. 

\todo{\url{https://www.archives.gov/files/applied-research/ncsa/8-an-overview-of-3d-data-content-file-formats-and-viewers.pdf}}

Cette abondance s'explique entre autres par la variété des domaines concernés : de la représentation de structure moléculaires (format XYZ\footnote{Spécifications du format \textit{XYZ} : \url{http://openbabel.org/wiki/XYZ_\%28format\%29}}), à la cryo-microscopie électronique (format MRC\footnote{Spécifications du format MRC : \url{http://www.ccpem.ac.uk/mrc_format/mrc2014.php}}), en passant par les formats de certains éditeurs de jeux ou consoles (\textit{MDX} chez \textit{Blizzard Entertainment},\textit{BDL} et \textit{BMD3} chez Nintendo...), et bien entendu tous les logiciels de modélisation/animation/CAD (\textit{Blend} pour \textit{Blender}, \textit{FBX}, \textit{MAX}, \textit{MB} et bien d'autres pour les différentes suites proposées par \textit{Autodesk}, \ldots).

Dans le cadre de ce projet, les formats qui nous intéressent sont bien entendu ceux qui concernent l'urbanisme, au travers des logiciels de CAO/DAO correspondants.

Enfin, il est important de savoir qu'un fichier 3D n'est pas qu'une simple liste de coordonnées 3-axes, mais contient généralement de nombreuses informations telles que : 
\begin{itemize}
    \item Caméras : types, emplacements, orientations...
    \item Lumières : types, emplacements, effets...
    \item Maillages (\textit{meshes}),
    \item Textures,
    \item Animations, sons...
\end{itemize}

Le contenu exact varie beaucoup d'un format à l'autre. Aussi, là où un certain format permettra de stocker l'ensemble des informations d'un modèle, un autre nécessitera de séparer les données (par exemple, un fichier pour le squelette, la lumière... et un autre pour les textures). \todo{Exemple concret} 

\todo{section dédiée à ce que contient un fichier 3D ?}

\subsection{Khronos Group}
\label{sec:khronos-group}
Le \textit{Khronos Group} est un consortium industriel à but non lucratif, dont le but est de définir des standards ouverts et libres de droits dans les domaines des graphiques 3D, de la réalité virtuelle et augmentée, et du traitement d'images notamment.

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{Figures/khronos-visual-computing-ecosystem.png}
    \captionsource{Ecosystème des standards proposés par \textit{Khronos}}{khronos-ecosystem}
    \label{fig:khronos-visual-computing-ecosystem}
\end{figure}

\subsection{Formats de fichiers de DAO/CAO courants}

Les formats les plus présents actuellement sont détaillés ci-après.

\subsubsection{FBX}
\textit{FBX} (\textbf{F}ilm\textbf{b}o\textbf{x}) est un format appartenant à \textit{Autodesk}.

Bien que propriétaire, une \textit{API}\footnote{\url{https://www.autodesk.com/products/fbx/overview}} fournit le nécessaire pour lire et écrire ces fichiers.

Il a été créé pour pallier les variétés de formats rencontrés dans le flux de travail, et ainsi assurer l'interopérabilité entre les produits d'\textit{Autodesk}, tels que \textit{3ds Max}, \textit{Maya} ou \textit{Motion Builder}, ainsi que de nombreux autres logiciels comme \textit{Cinema4D}, \textit{Rhino} ou \textit{Unity3D}.

De fait, cela en fait un format populaire, très répandu.
Une rapide recherche sur \textit{GitHub}\footnote{\url{https://github.com/search?q=fbx+viewer}} nous renvoie de nombreux projets de visionneuses \textit{FBX}.

\subsubsection{OBJ}
\textit{OBJ} est un format libre très utilisé pour transférer des informations d'une application à l'autre. Il s'agit d'un format de données simple, en \textit{ASCII}, qui sert uniquement à représenter la géométrie 3D (\textit{mesh}).

Comme ce format n'inclut pas les informations de couleurs, matériel, transformation et consort, un fichier \textit{MTL} (\textit{\textbf{M}aterial \textbf{T}emplate \textbf{L}ibrary} lui est généralement associé. Ce dernier définit les matériaux d'un objet 3D (coloration, texture, paramètres de réflexions optique...). Malheureusement \textit{MTL} est un format dépassé au vue des technologies actuelles, dont il ne supporte pas les plus récentes.

\subsubsection{3ds}
\textit{3ds} est l'un des formats utilisé par \textit{Autodesk 3ds Max}. Format natif du logiciel depuis son origine dans les années 90, cela en fait également un format très utilisé pour partager des modèles. Comme son concurrent \textit{OBJ}, il nécessite des fichiers complémentaires (\textit{MAX} pour stocker toutes les informations de la scène.

\subsubsection{COLLADA}
\textit{COLLADA} (\textit{\textbf{COLLA}borative \textbf{D}esign \textbf{A}ctivity})\footnote{\url{https://www.khronos.org/collada}} a intialement été développé par \textit{Sony Computer Entertainment}, et appartient actuellement au \textit{Khronos Group}.
C'est un format libre, dont la spécification est décrite par une norme ISO\footnote{ISO/PAS 17506:2012: \url{https://www.iso.org/standard/59902.html}}.

Il a été conçu pour faciliter les échanges entre les différents logiciels. Les documents \textit{COLLADA} décrivent les éléments selon un schéma \textit{XML}, et portent généralement l'extension \textit{DAE} (\textit{\textbf{D}igital \textbf{A}sset \textbf{E}xchange}.

Ce format est listé comme inactif dans la liste des standards du \textit{Khronos Group}. 
Bien que cela ne soit pas encore déclaré de façon officielle, il semble que le format \textit{glTF}, présenté en \ref{sec:glTF}, lui succède.

\subsubsection{glTF}
\label{sec:glTF}

\textit{glTF} (\textit{\textbf{GL} \textbf{T}ransmission \textbf{F}ormat})\footnote{\url{https://www.khronos.org/gltf/}} est un standard ouvert défini par le \textit{Khronos Group}. Visant le même objectif que son prédécesseur \textit{COLLADA}, ce format a été optimisé au mieux pour réduire l'espace de stockage nécessaire pour les scènes ou modèles 3D représentés, tout en accélérant le chargement et traitement de ceux-ci. 
\textit{Khronos} le décrit comme le "JPEG de la 3D".
Ce format utilise \textit{JSON} pour décrire les données.

Bien que relativement récent (fin 2015), il a rapidement été adopté par les principaux acteurs du marché, et son acceptation continue de s'étendre. À titre d'exemple, \textit{Sketchfab} propose déjà plus de 100'000 modèles dans ce format\footnote{\url{https://blog.sketchfab.com/sketchfab-now-largest-online-repository-gltf-files/}} et a défini \textit{glTF} comme format d'exportation par défaut. Tous les modèles, quelque soit leur format d'origine, peuvent être convertis automatiquement dans ce format lors de leur téléchargement. 

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{Figures/gltf-momentum.jpg}
    \captionsource{Outils, applications, plateformes et sociétés employant \textit{glTF}}{gltf-momentum}
    \label{fig:gltf-momentum}
\end{figure}

\subsection{Gestion des fichiers dans le cadre du projet}

On imagine trois cas de figure :

La première possibilité, illustrée en \ref{fig:file-importation-process-native}, est de faire en sorte que l'outil sache lire les fichiers "tels quels", sans effectuer de réelles transformations.
L'avantage est que, pour autant que l'on ait implémenté le support du format de fichier fournit en entrée, celui-ci sera vraisemblablement rendu correctement. C'est un peu le principe des visionneuses d'images classiques, auxquelles on donne les instructions sur "comment lire tel ou tel format de fichier", et qui affichent correctement chaque pixel à l'écran.
Le problème de cette solution est qu'elle nécessite un travail conséquent. Pour qu'elle soit efficace, il faut implémenter bon nombre de formats, et qu'il faut être certain de bien avoir respecter les specifications.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\linewidth]{Figures/file-importation-process-native.png}
    \caption{Cas 1 : support natif des principaux formats}
    \label{fig:file-importation-process-native}
\end{figure}

Une variante est de définir un ou quelques formats principaux, complètement supportés par le logiciel. Si l'utilisateur souhaite importer un modèle stocké sous un format non pris en charge, il devra le convertir manuellement, par exemple à l'aide des fonctions d'exportation du logiciel utilisé pour sa conception.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\linewidth]{Figures/file-importation-process-manual-conversion.png}
    \caption{Cas 2 : conversion manuelle vers le(s) format(s) supportés}
    \label{fig:file-importation-process-manual-conversion}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=\linewidth]{Figures/file-importation-process-auto-conversion.png}
    \caption{Cas 3 : conversion effectuée par le logiciel, si nécessaire}
    \label{fig:file-importation-process-auto-conversion}
\end{figure}


soit nativement (le logiciel sait lire différents formats), soit en se basant sur un format courant, vers lequel il est relativement aisé de convertir les autres types de fichiers au préalable.

\section{Système d'information géographique (SIG)}
Un \textit{SIG} est, comme son nom laisse supposer, un système d'information destiné à gérer des données spatiales ou géographiques. Il est difficile d'en donner une définition exacte, car les domaines concernés sont très vastes.

De manière générale, un \textit{SIG} sert à recueillir, stocker, analyser, éditer, partager et afficher lesdites données. Des outils sont mis à disposition des utilisateurs afin d'effectuer les tâches correspondantes, telles des requêtes sur les données.

Des exemples de SIG :

\begin{itemize}
    \item \textit{ArcGIS} de la société \textit{Esri}. C'est un ensemble complet de produits : du logiciel de bureau ou \textit{online}, en passant par des serveurs (managés ou hébergés chez \textit{Esri} ou encore sur un autre \textit{cloud}), ainsi que de nombreux outils de développement.
    \item \textit{QGIS} est un concurrent libre de \textit{ArcGIS}\footnote{Comparaison détaillée entre ArcGIS et QGIS (\textit{anglais, 2018}) : \url{https://gisgeography.com/qgis-arcgis-differences/}}
\end{itemize}

\section{Visionneuse de modèles 3D}

L'affichage et la manipulation de modèles 3D constitue la première brique d'un tel projet, la fondation sur laquelle viendront s'ajouter les modules complémentaires souhaités, tels que la création d'annotations, le stockage des modèles et des notes associées, etc.
Il existe de multiples visionneuses, qu'elles soient en ligne ou à installer. Le choix se réduit lorsque l'on recherche des projets open-source, ce qui était nécessaire de le cadre de ce projet : autant partir sur une base existante, et ne pas réinventer la roue.

\unsure{Suite à l'étude faite autour des formats de fichier, les recherches de visionneuses se sont limitées à celles supportant le format glTF.}

Parmi les projets open-source trouvé, nous nous sommes surtout intéressés à ceux actifs, c'est-à-dire ayant eu des activités récentes (mise à jour du code...). Parmi ces quelques-uns, voici les ceux qui auront retenus notre attention :

\begin{itemize}
    \item bwasty/gltf-viewer\footnote{\url{https://github.com/bwasty/gltf-viewer}} : développée en \textit{Rust}. Cette visionneuse est fonctionnelle, mais n'a pas été retenue d'une part car elle ne propose pas de version web, et d'autre part parce que je n'ai aucune expérience dans ce langage de programmation.
    \item pissang/clay-viewer\footnote{\url{https://github.com/pissang/clay-viewer}} : cette visionneuse permet de lire les fichiers \textit{FBX}, \textit{DAE} et \textit{OBJ}, et il est ensuite possible de les exporter au format \textit{glTF}. Les versions clients Windows et MacOS sont proposées. Très prometteur, ce projet n'a pas été retenu comme base pour deux raisons. La première, c'est qu'il n'est pas fait mention de version web - bien qu'en théorie, au vu des technologies utilisées (\textit{Javascript}, principalement), il serait possible de l'adapter. La seconde, c'est que le rendu est effectué à l'aide de ClayGL\footnote{\url{https://github.com/pissang/claygl}}, une librairie créée par le même développeur. Celle-ci est très prometteuse, maintenue activement à jour et commence à être utilisée dans quelques projets, mais n'est pas encore suffisamment répandue pour assurer que l'on trouvera suffisamment de documentation, exemples et aide en cas de besoin.
    \todo{propose un outil de conversion vers glTF, fait en python "ClayGL provide a python tool for converting FBX to glTF 2.0."}
\end{itemize}


Le choix s'est porté sur three-gltf-viewer.
Il s'agit d'un projet développé par un gars de chez Google, spécialisé dans...,  apparemment dans son temps libre.
Le projet a été démarré récemment (DATE) et toujours développé activement. Cela conforte dans l'idée que les technologies utilisées pour le concevoir soient modernes.

Les spécificités de ce projet sont détaillées sous "Langages et technologies".


\section{Langages et technologies}

Lorsque l'on se base sur un projet existant, l'une des contraintes et qu'il va falloir s'adapter aux technologies employées par celui-ci.

Un rapide tour d'horizon sur la page Github du projet, en activant l'affichage de la proportion d'utilisation de langages, nous apprend qu'il s'agit d'un projet web, composé essentiellement de JavaScript.

\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth]{Figures/three-gltf-viewer-github-preview.png}
    \caption{Statistiques du projet three-gltf-viewer}
    \label{fig:three-gltf-viewer-github-preview}
\end{figure}

Les répertoires situées à la racine nous apprennent l'utilisation du framework Electron https://electronjs.org/.
\subsection{Electron}

\subsection{NodeJS}
Package.json -> Node...

Migration JS -> TS : \url{https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html}
malheureusement prendrai trop de temps dans le cadre de ce projet. On peut mixer du TS dans du JS mais c'est pas très simple...
Guide pour migrer une app React vers TS : \url{https://github.com/Microsoft/TypeScript-React-Conversion-Guide\#typescript-react-conversion-guide}

Javascript : cours J-L Falcone https://gitlab.unige.ch/courses/jsHepia

\subsection{WebGL}
\textit{WebGL} est une API, basée sur \textit{OpenGL}, servant à afficher des graphiques 2D et 3D dans tout navigateur web compatible\footnote{\url{https://caniuse.com/\#feat=webgl}}, à travers le \textit{canvas} d'\textit{HTML5}. 
Le rendu, au travers du langage \textit{GLSL}, est réalisé par le \textit{GPU}, fournissant ainsi d'excellentes performances. Ces dernières peuvent toutefois être limitées, par exemple sur des ordinateurs équipées d'anciennes cartes graphiques ainsi que les smartphones à la configuration plus modeste.

\textit{WebGL} est développé par le groupe \textit{Khronos}, le même à l'origine du format \textit{glTF} présenté en \ref{sec:glTF}.


\subsection{Three.js}
\textit{Three.js}\footnote{\url{https://threejs.org/}} est une librairie \textit{JavaScript} libre, permettant de créer et afficher des éléments 3D dans un navigateur. Très répandue




\section{Annotations}

Dans nos discussions de cas d'utilisation et de fonctionnalités, pouvoir commenter et ajouter des informations à un modèle est un aspect qui a souvent été mentionné. C'est en effet une fonctionnalité importante pour toutes les catégories d'utilisateurs.

Dans le cadre d'une modélisation 3D, la particularité des annotations est d'être \textbf{associées à des coordonnées spécifiques} de celle-ci. Dans ce projet, c'est ce qui distingue les annotations de simples commentaires que l'on ajouterait en regard du modèle ou en dessous de celui-ci (comme des commentaires sur une photo ou une publication par exemple).

\subsection{Attributs d'une annotation}
Les données principales d'une annotation sont : son \textbf{contenu} et ses \text{information de localisation dans le modèle}.

Par contenu, on pense nécessairement à du texte, mais on peut aussi imaginer des images, des liens, une vue 360° prise à l'emplacement concerné, une vidéo, voire un autre modèle 3D (par exemple, de l'intérieur d'un bâtiment)...!

Dans \textit{Sketchfab}, les annotations ont un titre et une description. Cette dernière peut être rédigée en \textit{Markdown}; c'est de cette manière que l'on peut ajouter des liens et des images. Pour l'instant, la plateforme ne supporte pas les autres types de médias.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{Figures/sketchfab-annotation-with-picture.png}
    \caption{Exemple d'annotation avec une image dans~\textit{Sketchfab}}
    \label{fig:sketchfab-annotation-with-picture}
\end{figure}

L'ajout d'une annotation dans Sketchfab se déroule ainsi : en mode édition, avec l'outil d'annotation actif, un double-clic sur le modèle affiche une fenêtre pour rédiger le contenu de l'annotation. Celle-ci est ensuite représentée par un cercle numéroté, qui reste à l'emplacement choisi, même lorsque l'on manipule le modèle (pivoter, déplacer...). 

\begin{figure}
    \centering
    \includegraphics{Figures/sketchfab-adding-annotation.png}
    \caption{Exemple d'ajout d'une annotation en mode édition}
    \label{fig:sketchfab-adding-annotation}
\end{figure}

Au niveau technologique : les cercles sont des objets 3D ajoutés à la scène, généralement rendue en \textit{WebGL}. Le dialogue contenant l'annotation pourrait aussi être créé en \textit{WebGL}, mais \textit{HTML/CSS}  est bien mieux adapté pour tout ce qui a trait à la mise en page et aux typographies.

Parmi les fonctionnalités supplémentaires imaginées :


\todo{Images vues 360}

\todo{Concepts d'annotations : vue 360. naviguer dans une animation ? exemple : projet à plusieurs années d’intervalle, pouvoir bouger sur un curseur. \url{}}

\section{Stockage}
Stockage des modèles 3D :
plusieurs solutions sont envisageables. On pourrait utiliser une base de données spécifique aux SIG.
Une première implémentation serait faciliter par un simple stockage des fichiers à l'endroit d'exécution de l'application (sur son serveur p.ex.).


Stockage des annotations :
Format JSON

\subsection{GeoJSON}
\textit{GeoJSON} est un format ouvert,  basé sur JSON, développé pour représenter des caractéristiques géographiques.
Celles-ci incluent les points, les lignes et les polygones ainsi que des sous-ensembles de ces types. À ces éléments, on peut ajouter des attributs.



\section{Hébergement, déploiement}

\subsection{Déploiement en continu avec Heroku}

\textit{Heroku} est une Plateforme \textit{cloud} en tant que service (PaaS) qui offre l'infrastructure nécessaire au déploiement d'applications web. Ainsi, l'équipe de développement peut se concentrer sur le logiciel lui-même sans avoir à gérer la mise en place de serveurs, leur configuration etc.

Parmi les fonctionnalités proposées :
\begin{itemize}
    \item Possibilité de mettre à jour l'application automatiquement au moindre changement dans un \textit{repository} distant, par exemple si le projet est hébergé sur \textit{GitHub},
    \item Scalabilité des processus : en cas de montée en charge (augmentation du nombre de connexions, de traitements à effectuer...), le service offre la possibilité d'allouer des ressources supplémentaires
    \item Isolation : chaque processus est isolé des autres; ainsi si l'un pose problème, le reste du produit n'est pas impacté.
    \item Des logs complets et clairs pour dépanner efficacement son application,
    \item Une documentation vaste, de nombreuses ressources pour démarrer rapidement
\end{itemize}

\textit{Heroku} n'est évidemment pas la seule enterprise à proposer ce genre de services. Citons par exemple \textit{Amazon Web Services (AWS)}, \textit{Windows Azure} ou encore \textit{Google App Engine}.

\textit{Heroku} se démarque quelque peu de la concurrence grâce à la relative rapidité à laquelle on peut mettre en place une première application.


\subsubsection{Problèmes rencontrés}

Heroku considère que l'application se trouve à la racine du dossier.
Si l'application est située dans un sous-répertoire, l'une des possibilités est d'utiliser le module 'subtree' de git, qui permet de créer une sous-arborescence au sein d'un même projet. Ce dernier pourra alors être lié à une branche distincte, dans laquelle il se trouvera à la racine.
\begin{minted}{bash}
    git subtree push --prefix mysubtree origin subtree
\end{minted}

git subtree push --prefix mip-viewer origin heroku

Heroku est un environnement de production (pas de dev). Voir problème rencontré ici :

et commentaire :
Heroku is a production environment. The devDependencies are for packages that are required on your development environment only. Packages that you need to be included in your Heroku slug (including packages required during the slug build phase, such as webpack), need to be in your dependencies, not devDependencies. It is possible that you see people putting webpack in devDependencies for other platforms, but probably not for Heroku. 

et une possible solution étant de créer un script spécifique à Heroku : https://stackoverflow.com/a/42237745/1975002
Avantage : permet de ne pas faire grandir package.json, et d'isoler ce qui concerne Heroku.

Dans mon cas, comme seul le package 'webpack' était concerné, je l'ai "dédoublé" sous dependencies comme suggéré ici : https://stackoverflow.com/a/41973881/1975002

Heroku a pu ainsi faire une première build réussie de l'application. Celle-ci ne fonctionnait malheureusement pas encore correctement (voir \url{https://github.com/MichaelPolla/mip-viewer/issues/5\#issuecomment-390479224}) 